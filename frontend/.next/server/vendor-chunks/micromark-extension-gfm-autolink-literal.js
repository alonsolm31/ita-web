"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-autolink-literal";
exports.ids = ["vendor-chunks/micromark-extension-gfm-autolink-literal"];
exports.modules = {

/***/ "(rsc)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmAutolinkLiteralHtml: () => (/* binding */ gfmAutolinkLiteralHtml)\n/* harmony export */ });\n/* harmony import */ var micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-sanitize-uri */ \"(rsc)/./node_modules/micromark-util-sanitize-uri/dev/index.js\");\n/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').Handle} Handle\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */ \n/**\n * Create an HTML extension for `micromark` to support GitHub autolink literal\n * when serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GitHub autolink literal when serializing to HTML.\n */ function gfmAutolinkLiteralHtml() {\n    return {\n        exit: {\n            literalAutolinkEmail,\n            literalAutolinkHttp,\n            literalAutolinkWww\n        }\n    };\n}\n/**\n * @this {CompileContext}\n * @type {Handle}\n */ function literalAutolinkWww(token) {\n    anchorFromToken.call(this, token, \"http://\");\n}\n/**\n * @this {CompileContext}\n * @type {Handle}\n */ function literalAutolinkEmail(token) {\n    anchorFromToken.call(this, token, \"mailto:\");\n}\n/**\n * @this {CompileContext}\n * @type {Handle}\n */ function literalAutolinkHttp(token) {\n    anchorFromToken.call(this, token);\n}\n/**\n * @this CompileContext\n * @param {Token} token\n * @param {string | null | undefined} [protocol]\n * @returns {undefined}\n */ function anchorFromToken(token, protocol) {\n    const url = this.sliceSerialize(token);\n    this.tag('<a href=\"' + (0,micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_0__.sanitizeUri)((protocol || \"\") + url) + '\">');\n    this.raw(this.encode(url));\n    this.tag(\"</a>\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbC9kZXYvbGliL2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVzRDtBQUV2RDs7Ozs7OztDQU9DLEdBQ00sU0FBU0M7SUFDZCxPQUFPO1FBQ0xDLE1BQU07WUFBQ0M7WUFBc0JDO1lBQXFCQztRQUFrQjtJQUN0RTtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0EsbUJBQW1CQyxLQUFLO0lBQy9CQyxnQkFBZ0JDLElBQUksQ0FBQyxJQUFJLEVBQUVGLE9BQU87QUFDcEM7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSCxxQkFBcUJHLEtBQUs7SUFDakNDLGdCQUFnQkMsSUFBSSxDQUFDLElBQUksRUFBRUYsT0FBTztBQUNwQztBQUVBOzs7Q0FHQyxHQUNELFNBQVNGLG9CQUFvQkUsS0FBSztJQUNoQ0MsZ0JBQWdCQyxJQUFJLENBQUMsSUFBSSxFQUFFRjtBQUM3QjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsZ0JBQWdCRCxLQUFLLEVBQUVHLFFBQVE7SUFDdEMsTUFBTUMsTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0w7SUFDaEMsSUFBSSxDQUFDTSxHQUFHLENBQUMsY0FBY1osd0VBQVdBLENBQUMsQ0FBQ1MsWUFBWSxFQUFDLElBQUtDLE9BQU87SUFDN0QsSUFBSSxDQUFDRyxHQUFHLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNKO0lBQ3JCLElBQUksQ0FBQ0UsR0FBRyxDQUFDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2Rldi9saWIvaHRtbC5qcz82MWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db21waWxlQ29udGV4dH0gQ29tcGlsZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSGFuZGxlfSBIYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuSHRtbEV4dGVuc2lvbn0gSHRtbEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqL1xuXG5pbXBvcnQge3Nhbml0aXplVXJpfSBmcm9tICdtaWNyb21hcmstdXRpbC1zYW5pdGl6ZS11cmknXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdpdEh1YiBhdXRvbGluayBsaXRlcmFsXG4gKiB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHJldHVybnMge0h0bWxFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AgdG9cbiAqICAgc3VwcG9ydCBHaXRIdWIgYXV0b2xpbmsgbGl0ZXJhbCB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1BdXRvbGlua0xpdGVyYWxIdG1sKCkge1xuICByZXR1cm4ge1xuICAgIGV4aXQ6IHtsaXRlcmFsQXV0b2xpbmtFbWFpbCwgbGl0ZXJhbEF1dG9saW5rSHR0cCwgbGl0ZXJhbEF1dG9saW5rV3d3fVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0hhbmRsZX1cbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEF1dG9saW5rV3d3KHRva2VuKSB7XG4gIGFuY2hvckZyb21Ub2tlbi5jYWxsKHRoaXMsIHRva2VuLCAnaHR0cDovLycpXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0hhbmRsZX1cbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEF1dG9saW5rRW1haWwodG9rZW4pIHtcbiAgYW5jaG9yRnJvbVRva2VuLmNhbGwodGhpcywgdG9rZW4sICdtYWlsdG86Jylcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7SGFuZGxlfVxuICovXG5mdW5jdGlvbiBsaXRlcmFsQXV0b2xpbmtIdHRwKHRva2VuKSB7XG4gIGFuY2hvckZyb21Ub2tlbi5jYWxsKHRoaXMsIHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIENvbXBpbGVDb250ZXh0XG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvdG9jb2xdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhbmNob3JGcm9tVG9rZW4odG9rZW4sIHByb3RvY29sKSB7XG4gIGNvbnN0IHVybCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIHRoaXMudGFnKCc8YSBocmVmPVwiJyArIHNhbml0aXplVXJpKChwcm90b2NvbCB8fCAnJykgKyB1cmwpICsgJ1wiPicpXG4gIHRoaXMucmF3KHRoaXMuZW5jb2RlKHVybCkpXG4gIHRoaXMudGFnKCc8L2E+Jylcbn1cbiJdLCJuYW1lcyI6WyJzYW5pdGl6ZVVyaSIsImdmbUF1dG9saW5rTGl0ZXJhbEh0bWwiLCJleGl0IiwibGl0ZXJhbEF1dG9saW5rRW1haWwiLCJsaXRlcmFsQXV0b2xpbmtIdHRwIiwibGl0ZXJhbEF1dG9saW5rV3d3IiwidG9rZW4iLCJhbmNob3JGcm9tVG9rZW4iLCJjYWxsIiwicHJvdG9jb2wiLCJ1cmwiLCJzbGljZVNlcmlhbGl6ZSIsInRhZyIsInJhdyIsImVuY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmAutolinkLiteral: () => (/* binding */ gfmAutolinkLiteral)\n/* harmony export */ });\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ \"(rsc)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */ \n\nconst wwwPrefix = {\n    tokenize: tokenizeWwwPrefix,\n    partial: true\n};\nconst domain = {\n    tokenize: tokenizeDomain,\n    partial: true\n};\nconst path = {\n    tokenize: tokenizePath,\n    partial: true\n};\nconst trail = {\n    tokenize: tokenizeTrail,\n    partial: true\n};\nconst emailDomainDotTrail = {\n    tokenize: tokenizeEmailDomainDotTrail,\n    partial: true\n};\nconst wwwAutolink = {\n    tokenize: tokenizeWwwAutolink,\n    previous: previousWww\n};\nconst protocolAutolink = {\n    tokenize: tokenizeProtocolAutolink,\n    previous: previousProtocol\n};\nconst emailAutolink = {\n    tokenize: tokenizeEmailAutolink,\n    previous: previousEmail\n};\n/** @type {ConstructRecord} */ const text = {};\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */ function gfmAutolinkLiteral() {\n    return {\n        text\n    };\n}\n/** @type {Code} */ let code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.digit0;\n// Add alphanumerics.\nwhile(code < micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace){\n    text[code] = emailAutolink;\n    code++;\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon) code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseA;\n    else if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket) code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseA;\n}\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.plusSign] = emailAutolink;\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash] = emailAutolink;\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot] = emailAutolink;\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore] = emailAutolink;\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseH] = [\n    emailAutolink,\n    protocolAutolink\n];\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseH] = [\n    emailAutolink,\n    protocolAutolink\n];\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW] = [\n    emailAutolink,\n    wwwAutolink\n];\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW] = [\n    emailAutolink,\n    wwwAutolink\n];\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeEmailAutolink(effects, ok, nok) {\n    const self = this;\n    /** @type {boolean | undefined} */ let dot;\n    /** @type {boolean} */ let data;\n    return start;\n    /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function start(code) {\n        if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n            return nok(code);\n        }\n        effects.enter(\"literalAutolink\");\n        effects.enter(\"literalAutolinkEmail\");\n        return atext(code);\n    }\n    /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function atext(code) {\n        if (gfmAtext(code)) {\n            effects.consume(code);\n            return atext;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.atSign) {\n            effects.consume(code);\n            return emailDomain;\n        }\n        return nok(code);\n    }\n    /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */ function emailDomain(code) {\n        // Dot followed by alphanumerical (not `-` or `_`).\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot) {\n            return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n        }\n        // Alphanumerical, `-`, and `_`.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)) {\n            data = true;\n            effects.consume(code);\n            return emailDomain;\n        }\n        // To do: `/` if xmpp.\n        // Note: normally we’d truncate trailing punctuation from the link.\n        // However, email autolink literals cannot contain any of those markers,\n        // except for `.`, but that can only occur if it isn’t trailing.\n        // So we can ignore truncating!\n        return emailDomainAfter(code);\n    }\n    /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */ function emailDomainDot(code) {\n        effects.consume(code);\n        dot = true;\n        return emailDomain;\n    }\n    /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */ function emailDomainAfter(code) {\n        // Domain must not be empty, must include a dot, and must end in alphabetical.\n        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n        if (data && dot && (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(self.previous)) {\n            effects.exit(\"literalAutolinkEmail\");\n            effects.exit(\"literalAutolink\");\n            return ok(code);\n        }\n        return nok(code);\n    }\n}\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeWwwAutolink(effects, ok, nok) {\n    const self = this;\n    return wwwStart;\n    /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function wwwStart(code) {\n        if (code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW && code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n            return nok(code);\n        }\n        effects.enter(\"literalAutolink\");\n        effects.enter(\"literalAutolinkWww\");\n        // Note: we *check*, so we can discard the `www.` we parsed.\n        // If it worked, we consider it as a part of the domain.\n        return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n    }\n    /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */ function wwwAfter(code) {\n        effects.exit(\"literalAutolinkWww\");\n        effects.exit(\"literalAutolink\");\n        return ok(code);\n    }\n}\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeProtocolAutolink(effects, ok, nok) {\n    const self = this;\n    let buffer = \"\";\n    let seen = false;\n    return protocolStart;\n    /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function protocolStart(code) {\n        if ((code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseH || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseH) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n            effects.enter(\"literalAutolink\");\n            effects.enter(\"literalAutolinkHttp\");\n            buffer += String.fromCodePoint(code);\n            effects.consume(code);\n            return protocolPrefixInside;\n        }\n        return nok(code);\n    }\n    /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */ function protocolPrefixInside(code) {\n        // `5` is size of `https`\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code) && buffer.length < 5) {\n            // @ts-expect-error: definitely number.\n            buffer += String.fromCodePoint(code);\n            effects.consume(code);\n            return protocolPrefixInside;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon) {\n            const protocol = buffer.toLowerCase();\n            if (protocol === \"http\" || protocol === \"https\") {\n                effects.consume(code);\n                return protocolSlashesInside;\n            }\n        }\n        return nok(code);\n    }\n    /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */ function protocolSlashesInside(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.slash) {\n            effects.consume(code);\n            if (seen) {\n                return afterProtocol;\n            }\n            seen = true;\n            return protocolSlashesInside;\n        }\n        return nok(code);\n    }\n    /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */ function afterProtocol(code) {\n        // To do: this is different from `markdown-rs`:\n        // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n        return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiControl)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodePunctuation)(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n    }\n    /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */ function protocolAfter(code) {\n        effects.exit(\"literalAutolinkHttp\");\n        effects.exit(\"literalAutolink\");\n        return ok(code);\n    }\n}\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeWwwPrefix(effects, ok, nok) {\n    let size = 0;\n    return wwwPrefixInside;\n    /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */ function wwwPrefixInside(code) {\n        if ((code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW) && size < 3) {\n            size++;\n            effects.consume(code);\n            return wwwPrefixInside;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot && size === 3) {\n            effects.consume(code);\n            return wwwPrefixAfter;\n        }\n        return nok(code);\n    }\n    /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function wwwPrefixAfter(code) {\n        // If there is *anything*, we can link.\n        return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ? nok(code) : ok(code);\n    }\n}\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeDomain(effects, ok, nok) {\n    /** @type {boolean | undefined} */ let underscoreInLastSegment;\n    /** @type {boolean | undefined} */ let underscoreInLastLastSegment;\n    /** @type {boolean | undefined} */ let seen;\n    return domainInside;\n    /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */ function domainInside(code) {\n        // Check whether this marker, which is a trailing punctuation\n        // marker, optionally followed by more trailing markers, and then\n        // followed by an end.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore) {\n            return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n        }\n        // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n        // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n        // so that’s Unicode.\n        // Instead of some new production for Unicode alphanumerics, markdown\n        // already has that for Unicode punctuation and whitespace, so use those.\n        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code) || code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash && (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodePunctuation)(code)) {\n            return domainAfter(code);\n        }\n        seen = true;\n        effects.consume(code);\n        return domainInside;\n    }\n    /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */ function domainAtPunctuation(code) {\n        // There is an underscore in the last segment of the domain\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore) {\n            underscoreInLastSegment = true;\n        } else {\n            underscoreInLastLastSegment = underscoreInLastSegment;\n            underscoreInLastSegment = undefined;\n        }\n        effects.consume(code);\n        return domainInside;\n    }\n    /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */ function domainAfter(code) {\n        // Note: that’s GH says a dot is needed, but it’s not true:\n        // <https://github.com/github/cmark-gfm/issues/279>\n        if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n            return nok(code);\n        }\n        return ok(code);\n    }\n}\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizePath(effects, ok) {\n    let sizeOpen = 0;\n    let sizeClose = 0;\n    return pathInside;\n    /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */ function pathInside(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis) {\n            sizeOpen++;\n            effects.consume(code);\n            return pathInside;\n        }\n        // To do: `markdown-rs` also needs this.\n        // If this is a paren, and there are less closings than openings,\n        // we don’t check for a trail.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis && sizeClose < sizeOpen) {\n            return pathAtPunctuation(code);\n        }\n        // Check whether this trailing punctuation marker is optionally\n        // followed by more trailing markers, and then followed\n        // by an end.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.exclamationMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.quotationMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.ampersand || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.apostrophe || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.comma || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.questionMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde) {\n            return effects.check(trail, ok, pathAtPunctuation)(code);\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)) {\n            return ok(code);\n        }\n        effects.consume(code);\n        return pathInside;\n    }\n    /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */ function pathAtPunctuation(code) {\n        // Count closing parens.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis) {\n            sizeClose++;\n        }\n        effects.consume(code);\n        return pathInside;\n    }\n}\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeTrail(effects, ok, nok) {\n    return trail;\n    /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */ function trail(code) {\n        // Regular trailing punctuation.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.exclamationMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.quotationMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.apostrophe || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.comma || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.questionMark || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde) {\n            effects.consume(code);\n            return trail;\n        }\n        // `&` followed by one or more alphabeticals and then a `;`, is\n        // as a whole considered as trailing punctuation.\n        // In all other cases, it is considered as continuation of the URL.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.ampersand) {\n            effects.consume(code);\n            return trailCharRefStart;\n        }\n        // Needed because we allow literals after `[`, as we fix:\n        // <https://github.com/github/cmark-gfm/issues/278>.\n        // Check that it is not followed by `(` or `[`.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket) {\n            effects.consume(code);\n            return trailBracketAfter;\n        }\n        if (// `<` is an end.\n        code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan || // So is whitespace.\n        code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)) {\n            return ok(code);\n        }\n        return nok(code);\n    }\n    /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */ function trailBracketAfter(code) {\n        // Whitespace or something that could start a resource or reference is the end.\n        // Switch back to trail otherwise.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)) {\n            return ok(code);\n        }\n        return trail(code);\n    }\n    /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */ function trailCharRefStart(code) {\n        // When non-alpha, it’s not a trail.\n        return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code) ? trailCharRefInside(code) : nok(code);\n    }\n    /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */ function trailCharRefInside(code) {\n        // Switch back to trail if this is well-formed.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon) {\n            effects.consume(code);\n            return trail;\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {\n            effects.consume(code);\n            return trailCharRefInside;\n        }\n        // It’s not a trail.\n        return nok(code);\n    }\n}\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeEmailDomainDotTrail(effects, ok, nok) {\n    return start;\n    /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */ function start(code) {\n        // Must be dot.\n        effects.consume(code);\n        return after;\n    }\n    /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */ function after(code) {\n        // Not a trail if alphanumeric.\n        return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code) ? nok(code) : ok(code);\n    }\n}\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */ function previousWww(code) {\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code);\n}\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */ function previousProtocol(code) {\n    return !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code);\n}\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */ function previousEmail(code) {\n    // Do not allow a slash “inside” atext.\n    // The reference code is a bit weird, but that’s what it results in.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n    // Other than slash, every preceding character is allowed.\n    return !(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.slash || gfmAtext(code));\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */ function gfmAtext(code) {\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.plusSign || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code);\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */ function previousUnbalanced(events) {\n    let index = events.length;\n    let result = false;\n    while(index--){\n        const token = events[index][1];\n        if ((token.type === \"labelLink\" || token.type === \"labelImage\") && !token._balanced) {\n            result = true;\n            break;\n        }\n        // If we’ve seen this token, and it was marked as not having any unbalanced\n        // bracket before it, we can exit.\n        if (token._gfmAutolinkLiteralWalkedInto) {\n            result = false;\n            break;\n        }\n    }\n    if (events.length > 0 && !result) {\n        // Mark the last token as “walked into” w/o finding\n        // anything.\n        events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbC9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FTZ0M7QUFDVTtBQUUzQyxNQUFNTyxZQUFZO0lBQUNDLFVBQVVDO0lBQW1CQyxTQUFTO0FBQUk7QUFDN0QsTUFBTUMsU0FBUztJQUFDSCxVQUFVSTtJQUFnQkYsU0FBUztBQUFJO0FBQ3ZELE1BQU1HLE9BQU87SUFBQ0wsVUFBVU07SUFBY0osU0FBUztBQUFJO0FBQ25ELE1BQU1LLFFBQVE7SUFBQ1AsVUFBVVE7SUFBZU4sU0FBUztBQUFJO0FBQ3JELE1BQU1PLHNCQUFzQjtJQUMxQlQsVUFBVVU7SUFDVlIsU0FBUztBQUNYO0FBRUEsTUFBTVMsY0FBYztJQUFDWCxVQUFVWTtJQUFxQkMsVUFBVUM7QUFBVztBQUN6RSxNQUFNQyxtQkFBbUI7SUFDdkJmLFVBQVVnQjtJQUNWSCxVQUFVSTtBQUNaO0FBQ0EsTUFBTUMsZ0JBQWdCO0lBQUNsQixVQUFVbUI7SUFBdUJOLFVBQVVPO0FBQWE7QUFFL0UsNEJBQTRCLEdBQzVCLE1BQU1DLE9BQU8sQ0FBQztBQUVkOzs7Ozs7O0NBT0MsR0FDTSxTQUFTQztJQUNkLE9BQU87UUFBQ0Q7SUFBSTtBQUNkO0FBRUEsaUJBQWlCLEdBQ2pCLElBQUlFLE9BQU96Qix3REFBS0EsQ0FBQzBCLE1BQU07QUFFdkIscUJBQXFCO0FBQ3JCLE1BQU9ELE9BQU96Qix3REFBS0EsQ0FBQzJCLGNBQWMsQ0FBRTtJQUNsQ0osSUFBSSxDQUFDRSxLQUFLLEdBQUdMO0lBQ2JLO0lBQ0EsSUFBSUEsU0FBU3pCLHdEQUFLQSxDQUFDNEIsS0FBSyxFQUFFSCxPQUFPekIsd0RBQUtBLENBQUM2QixVQUFVO1NBQzVDLElBQUlKLFNBQVN6Qix3REFBS0EsQ0FBQzhCLGlCQUFpQixFQUFFTCxPQUFPekIsd0RBQUtBLENBQUMrQixVQUFVO0FBQ3BF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RjtJQUVBLElBQUkxRCxPQUFPbUIsTUFBTSxHQUFHLEtBQUssQ0FBQ3VDLFFBQVE7UUFDaEMsbURBQW1EO1FBQ25ELFlBQVk7UUFDWjFELE1BQU0sQ0FBQ0EsT0FBT21CLE1BQU0sR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDMkMsNkJBQTZCLEdBQUc7SUFDL0Q7SUFFQSxPQUFPSjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbC9kZXYvbGliL3N5bnRheC5qcz80Mzk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkNvbnN0cnVjdFJlY29yZH0gQ29uc3RydWN0UmVjb3JkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QcmV2aW91c30gUHJldmlvdXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuU3RhdGV9IFN0YXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplcn0gVG9rZW5pemVyXG4gKi9cblxuaW1wb3J0IHtcbiAgYXNjaWlBbHBoYSxcbiAgYXNjaWlBbHBoYW51bWVyaWMsXG4gIGFzY2lpQ29udHJvbCxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgdW5pY29kZVB1bmN0dWF0aW9uLFxuICB1bmljb2RlV2hpdGVzcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5cbmNvbnN0IHd3d1ByZWZpeCA9IHt0b2tlbml6ZTogdG9rZW5pemVXd3dQcmVmaXgsIHBhcnRpYWw6IHRydWV9XG5jb25zdCBkb21haW4gPSB7dG9rZW5pemU6IHRva2VuaXplRG9tYWluLCBwYXJ0aWFsOiB0cnVlfVxuY29uc3QgcGF0aCA9IHt0b2tlbml6ZTogdG9rZW5pemVQYXRoLCBwYXJ0aWFsOiB0cnVlfVxuY29uc3QgdHJhaWwgPSB7dG9rZW5pemU6IHRva2VuaXplVHJhaWwsIHBhcnRpYWw6IHRydWV9XG5jb25zdCBlbWFpbERvbWFpbkRvdFRyYWlsID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVFbWFpbERvbWFpbkRvdFRyYWlsLFxuICBwYXJ0aWFsOiB0cnVlXG59XG5cbmNvbnN0IHd3d0F1dG9saW5rID0ge3Rva2VuaXplOiB0b2tlbml6ZVd3d0F1dG9saW5rLCBwcmV2aW91czogcHJldmlvdXNXd3d9XG5jb25zdCBwcm90b2NvbEF1dG9saW5rID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVQcm90b2NvbEF1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNQcm90b2NvbFxufVxuY29uc3QgZW1haWxBdXRvbGluayA9IHt0b2tlbml6ZTogdG9rZW5pemVFbWFpbEF1dG9saW5rLCBwcmV2aW91czogcHJldmlvdXNFbWFpbH1cblxuLyoqIEB0eXBlIHtDb25zdHJ1Y3RSZWNvcmR9ICovXG5jb25zdCB0ZXh0ID0ge31cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdpdEh1YiBhdXRvbGluayBsaXRlcmFsXG4gKiBzeW50YXguXG4gKlxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGV4dGVuc2lvbnNgIHRvIGVuYWJsZSBHRk1cbiAqICAgYXV0b2xpbmsgbGl0ZXJhbCBzeW50YXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1BdXRvbGlua0xpdGVyYWwoKSB7XG4gIHJldHVybiB7dGV4dH1cbn1cblxuLyoqIEB0eXBlIHtDb2RlfSAqL1xubGV0IGNvZGUgPSBjb2Rlcy5kaWdpdDBcblxuLy8gQWRkIGFscGhhbnVtZXJpY3MuXG53aGlsZSAoY29kZSA8IGNvZGVzLmxlZnRDdXJseUJyYWNlKSB7XG4gIHRleHRbY29kZV0gPSBlbWFpbEF1dG9saW5rXG4gIGNvZGUrK1xuICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIGNvZGUgPSBjb2Rlcy51cHBlcmNhc2VBXG4gIGVsc2UgaWYgKGNvZGUgPT09IGNvZGVzLmxlZnRTcXVhcmVCcmFja2V0KSBjb2RlID0gY29kZXMubG93ZXJjYXNlQVxufVxuXG50ZXh0W2NvZGVzLnBsdXNTaWduXSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbY29kZXMuZGFzaF0gPSBlbWFpbEF1dG9saW5rXG50ZXh0W2NvZGVzLmRvdF0gPSBlbWFpbEF1dG9saW5rXG50ZXh0W2NvZGVzLnVuZGVyc2NvcmVdID0gZW1haWxBdXRvbGlua1xudGV4dFtjb2Rlcy51cHBlcmNhc2VIXSA9IFtlbWFpbEF1dG9saW5rLCBwcm90b2NvbEF1dG9saW5rXVxudGV4dFtjb2Rlcy5sb3dlcmNhc2VIXSA9IFtlbWFpbEF1dG9saW5rLCBwcm90b2NvbEF1dG9saW5rXVxudGV4dFtjb2Rlcy51cHBlcmNhc2VXXSA9IFtlbWFpbEF1dG9saW5rLCB3d3dBdXRvbGlua11cbnRleHRbY29kZXMubG93ZXJjYXNlV10gPSBbZW1haWxBdXRvbGluaywgd3d3QXV0b2xpbmtdXG5cbi8vIFRvIGRvOiBwZXJmb3JtIGVtYWlsIGF1dG9saW5rIGxpdGVyYWxzIG9uIGV2ZW50cywgYWZ0ZXJ3YXJkcy5cbi8vIFRoYXTigJlzIHdoZXJlIGBtYXJrZG93bi1yc2AgYW5kIGBjbWFyay1nZm1gIHBlcmZvcm0gaXQuXG4vLyBJdCBzaG91bGQgbG9vayBmb3IgYEBgLCB0aGVuIGZvciBhdGV4dCBiYWNrd2FyZHMsIGFuZCB0aGVuIGZvciBhIGxhYmVsXG4vLyBmb3J3YXJkcy5cbi8vIFRvIGRvOiBgbWFpbHRvOmAsIGB4bXBwOmAgcHJvdG9jb2wgYXMgcHJlZml4LlxuXG4vKipcbiAqIEVtYWlsIGF1dG9saW5rIGxpdGVyYWwuXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXl5eXl5eXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRW1haWxBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGRvdFxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIGxldCBkYXRhXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGVtYWlsIGF1dG9saW5rIGxpdGVyYWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgIWdmbUF0ZXh0KGNvZGUpIHx8XG4gICAgICAhcHJldmlvdXNFbWFpbC5jYWxsKHNlbGYsIHNlbGYucHJldmlvdXMpIHx8XG4gICAgICBwcmV2aW91c1VuYmFsYW5jZWQoc2VsZi5ldmVudHMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rJylcbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmtFbWFpbCcpXG4gICAgcmV0dXJuIGF0ZXh0KGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gZW1haWwgYXRleHQuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBhdGV4dChjb2RlKSB7XG4gICAgaWYgKGdmbUF0ZXh0KGNvZGUpKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBhdGV4dFxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5hdFNpZ24pIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGVtYWlsRG9tYWluXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGVtYWlsIGRvbWFpbi5cbiAgICpcbiAgICogVGhlIHJlZmVyZW5jZSBjb2RlIGlzIGEgYml0IG92ZXJseSBjb21wbGV4IGFzIGl0IGhhbmRsZXMgdGhlIGBAYCwgb2Ygd2hpY2hcbiAgICogdGhlcmUgbWF5IGJlIGp1c3Qgb25lLlxuICAgKiBTb3VyY2U6IDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9ibG9iL2VmMWNmY2IvZXh0ZW5zaW9ucy9hdXRvbGluay5jI0wzMTg+XG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVtYWlsRG9tYWluKGNvZGUpIHtcbiAgICAvLyBEb3QgZm9sbG93ZWQgYnkgYWxwaGFudW1lcmljYWwgKG5vdCBgLWAgb3IgYF9gKS5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZG90KSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayhcbiAgICAgICAgZW1haWxEb21haW5Eb3RUcmFpbCxcbiAgICAgICAgZW1haWxEb21haW5BZnRlcixcbiAgICAgICAgZW1haWxEb21haW5Eb3RcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBbHBoYW51bWVyaWNhbCwgYC1gLCBhbmQgYF9gLlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IGNvZGVzLmRhc2ggfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnVuZGVyc2NvcmUgfHxcbiAgICAgIGFzY2lpQWxwaGFudW1lcmljKGNvZGUpXG4gICAgKSB7XG4gICAgICBkYXRhID0gdHJ1ZVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZW1haWxEb21haW5cbiAgICB9XG5cbiAgICAvLyBUbyBkbzogYC9gIGlmIHhtcHAuXG5cbiAgICAvLyBOb3RlOiBub3JtYWxseSB3ZeKAmWQgdHJ1bmNhdGUgdHJhaWxpbmcgcHVuY3R1YXRpb24gZnJvbSB0aGUgbGluay5cbiAgICAvLyBIb3dldmVyLCBlbWFpbCBhdXRvbGluayBsaXRlcmFscyBjYW5ub3QgY29udGFpbiBhbnkgb2YgdGhvc2UgbWFya2VycyxcbiAgICAvLyBleGNlcHQgZm9yIGAuYCwgYnV0IHRoYXQgY2FuIG9ubHkgb2NjdXIgaWYgaXQgaXNu4oCZdCB0cmFpbGluZy5cbiAgICAvLyBTbyB3ZSBjYW4gaWdub3JlIHRydW5jYXRpbmchXG4gICAgcmV0dXJuIGVtYWlsRG9tYWluQWZ0ZXIoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBlbWFpbCBkb21haW4sIG9uIGRvdCB0aGF0IGlzIG5vdCBhIHRyYWlsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW1haWxEb21haW5Eb3QoY29kZSkge1xuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGRvdCA9IHRydWVcbiAgICByZXR1cm4gZW1haWxEb21haW5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBlbWFpbCBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIGNvbnRhY3RAZXhhbXBsZS5vcmcgYlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW1haWxEb21haW5BZnRlcihjb2RlKSB7XG4gICAgLy8gRG9tYWluIG11c3Qgbm90IGJlIGVtcHR5LCBtdXN0IGluY2x1ZGUgYSBkb3QsIGFuZCBtdXN0IGVuZCBpbiBhbHBoYWJldGljYWwuXG4gICAgLy8gU291cmNlOiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMzMyPi5cbiAgICBpZiAoZGF0YSAmJiBkb3QgJiYgYXNjaWlBbHBoYShzZWxmLnByZXZpb3VzKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmtFbWFpbCcpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBgd3d3YCBhdXRvbGluayBsaXRlcmFsLlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSB3d3cuZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXl5eXl5eXl5eXl5eXG4gKiBgYGBcbiAqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVXd3dBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgcmV0dXJuIHd3d1N0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIHd3dyBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgd3d3LmV4YW1wbGUuY29tL2E/YiNjXG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB3d3dTdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgKGNvZGUgIT09IGNvZGVzLnVwcGVyY2FzZVcgJiYgY29kZSAhPT0gY29kZXMubG93ZXJjYXNlVykgfHxcbiAgICAgICFwcmV2aW91c1d3dy5jYWxsKHNlbGYsIHNlbGYucHJldmlvdXMpIHx8XG4gICAgICBwcmV2aW91c1VuYmFsYW5jZWQoc2VsZi5ldmVudHMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rJylcbiAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmtXd3cnKVxuICAgIC8vIE5vdGU6IHdlICpjaGVjayosIHNvIHdlIGNhbiBkaXNjYXJkIHRoZSBgd3d3LmAgd2UgcGFyc2VkLlxuICAgIC8vIElmIGl0IHdvcmtlZCwgd2UgY29uc2lkZXIgaXQgYXMgYSBwYXJ0IG9mIHRoZSBkb21haW4uXG4gICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICB3d3dQcmVmaXgsXG4gICAgICBlZmZlY3RzLmF0dGVtcHQoZG9tYWluLCBlZmZlY3RzLmF0dGVtcHQocGF0aCwgd3d3QWZ0ZXIpLCBub2spLFxuICAgICAgbm9rXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGEgd3d3IGF1dG9saW5rIGxpdGVyYWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB3d3cuZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHd3d0FmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua1d3dycpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogUHJvdG9jb2wgYXV0b2xpbmsgbGl0ZXJhbC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgaHR0cHM6Ly9leGFtcGxlLm9yZyBiXG4gKiAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5eXG4gKiBgYGBcbiAqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVQcm90b2NvbEF1dG9saW5rKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgbGV0IGJ1ZmZlciA9ICcnXG4gIGxldCBzZWVuID0gZmFsc2VcblxuICByZXR1cm4gcHJvdG9jb2xTdGFydFxuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBwcm90b2NvbCBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvdG9jb2xTdGFydChjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgKGNvZGUgPT09IGNvZGVzLnVwcGVyY2FzZUggfHwgY29kZSA9PT0gY29kZXMubG93ZXJjYXNlSCkgJiZcbiAgICAgIHByZXZpb3VzUHJvdG9jb2wuY2FsbChzZWxmLCBzZWxmLnByZXZpb3VzKSAmJlxuICAgICAgIXByZXZpb3VzVW5iYWxhbmNlZChzZWxmLmV2ZW50cylcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmtIdHRwJylcbiAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gcHJvdG9jb2xQcmVmaXhJbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gcHJvdG9jb2wuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2E/YiNjXG4gICAqICAgICBeXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvdG9jb2xQcmVmaXhJbnNpZGUoY29kZSkge1xuICAgIC8vIGA1YCBpcyBzaXplIG9mIGBodHRwc2BcbiAgICBpZiAoYXNjaWlBbHBoYShjb2RlKSAmJiBidWZmZXIubGVuZ3RoIDwgNSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogZGVmaW5pdGVseSBudW1iZXIuXG4gICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHByb3RvY29sUHJlZml4SW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmNvbG9uKSB7XG4gICAgICBjb25zdCBwcm90b2NvbCA9IGJ1ZmZlci50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChwcm90b2NvbCA9PT0gJ2h0dHAnIHx8IHByb3RvY29sID09PSAnaHR0cHMnKSB7XG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICByZXR1cm4gcHJvdG9jb2xTbGFzaGVzSW5zaWRlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHNsYXNoZXMuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2E/YiNjXG4gICAqICAgICAgICAgICBeXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvdG9jb2xTbGFzaGVzSW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuc2xhc2gpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICByZXR1cm4gYWZ0ZXJQcm90b2NvbFxuICAgICAgfVxuXG4gICAgICBzZWVuID0gdHJ1ZVxuICAgICAgcmV0dXJuIHByb3RvY29sU2xhc2hlc0luc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBwcm90b2NvbCwgYmVmb3JlIGRvbWFpbi5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYWZ0ZXJQcm90b2NvbChjb2RlKSB7XG4gICAgLy8gVG8gZG86IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gYG1hcmtkb3duLXJzYDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvYjNhOTIxYzc2MTMwOWFlMDBhNTFmZTM0OGQ4YTQzYWRiYzU0YjUxOC9zcmMvY29uc3RydWN0L2dmbV9hdXRvbGlua19saXRlcmFsLnJzI0wxNzItTDE4MlxuICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGFzY2lpQ29udHJvbChjb2RlKSB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKVxuICAgICAgPyBub2soY29kZSlcbiAgICAgIDogZWZmZWN0cy5hdHRlbXB0KGRvbWFpbiwgZWZmZWN0cy5hdHRlbXB0KHBhdGgsIHByb3RvY29sQWZ0ZXIpLCBub2spKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYSBwcm90b2NvbCBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sQWZ0ZXIoY29kZSkge1xuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogYHd3d2AgcHJlZml4LlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSB3d3cuZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplV3d3UHJlZml4KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgbGV0IHNpemUgPSAwXG5cbiAgcmV0dXJuIHd3d1ByZWZpeEluc2lkZVxuXG4gIC8qKlxuICAgKiBJbiB3d3cgcHJlZml4LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgd3d3LmV4YW1wbGUuY29tXG4gICAqICAgICBeXl5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB3d3dQcmVmaXhJbnNpZGUoY29kZSkge1xuICAgIGlmICgoY29kZSA9PT0gY29kZXMudXBwZXJjYXNlVyB8fCBjb2RlID09PSBjb2Rlcy5sb3dlcmNhc2VXKSAmJiBzaXplIDwgMykge1xuICAgICAgc2l6ZSsrXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB3d3dQcmVmaXhJbnNpZGVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZG90ICYmIHNpemUgPT09IDMpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHd3d1ByZWZpeEFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIHd3dyBwcmVmaXguXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB3d3cuZXhhbXBsZS5jb21cbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB3d3dQcmVmaXhBZnRlcihjb2RlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgKmFueXRoaW5nKiwgd2UgY2FuIGxpbmsuXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmVvZiA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBEb21haW4uXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBhIGh0dHBzOi8vZXhhbXBsZS5vcmcgYlxuICogICAgICAgICAgICAgICBeXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRG9tYWluKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgdW5kZXJzY29yZUluTGFzdFNlZ21lbnRcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgdW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHNlZW5cblxuICByZXR1cm4gZG9tYWluSW5zaWRlXG5cbiAgLyoqXG4gICAqIEluIGRvbWFpbi5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYVxuICAgKiAgICAgICAgICAgICBeXl5eXl5eXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZG9tYWluSW5zaWRlKGNvZGUpIHtcbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgbWFya2VyLCB3aGljaCBpcyBhIHRyYWlsaW5nIHB1bmN0dWF0aW9uXG4gICAgLy8gbWFya2VyLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IG1vcmUgdHJhaWxpbmcgbWFya2VycywgYW5kIHRoZW5cbiAgICAvLyBmb2xsb3dlZCBieSBhbiBlbmQuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRvdCB8fCBjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayh0cmFpbCwgZG9tYWluQWZ0ZXIsIGRvbWFpbkF0UHVuY3R1YXRpb24pKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gR0ggZG9jdW1lbnRzIHRoYXQgb25seSBhbHBoYW51bWVyaWNzIChvdGhlciB0aGFuIGAtYCwgYC5gLCBhbmQgYF9gKSBjYW5cbiAgICAvLyBvY2N1ciwgd2hpY2ggc291bmRzIGxpa2UgQVNDSUkgb25seSwgYnV0IHRoZXkgYWxzbyBzdXBwb3J0IGB3d3cu6bue55yLLmNvbWAsXG4gICAgLy8gc28gdGhhdOKAmXMgVW5pY29kZS5cbiAgICAvLyBJbnN0ZWFkIG9mIHNvbWUgbmV3IHByb2R1Y3Rpb24gZm9yIFVuaWNvZGUgYWxwaGFudW1lcmljcywgbWFya2Rvd25cbiAgICAvLyBhbHJlYWR5IGhhcyB0aGF0IGZvciBVbmljb2RlIHB1bmN0dWF0aW9uIGFuZCB3aGl0ZXNwYWNlLCBzbyB1c2UgdGhvc2UuXG4gICAgLy8gU291cmNlOiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMTI+LlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IGNvZGVzLmVvZiB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIChjb2RlICE9PSBjb2Rlcy5kYXNoICYmIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkb21haW5BZnRlcihjb2RlKVxuICAgIH1cblxuICAgIHNlZW4gPSB0cnVlXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGRvbWFpbkluc2lkZVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGRvbWFpbiwgYXQgcG90ZW50aWFsIHRyYWlsaW5nIHB1bmN0dWF0aW9uLCB0aGF0IHdhcyBub3QgdHJhaWxpbmcuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tXG4gICAqICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBkb21haW5BdFB1bmN0dWF0aW9uKGNvZGUpIHtcbiAgICAvLyBUaGVyZSBpcyBhbiB1bmRlcnNjb3JlIGluIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRvbWFpblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlKSB7XG4gICAgICB1bmRlcnNjb3JlSW5MYXN0U2VnbWVudCA9IHRydWVcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBpdOKAmXMgYSBgLmA6IHNhdmUgdGhlIGxhc3Qgc2VnbWVudCB1bmRlcnNjb3JlIGluIHRoZVxuICAgIC8vIHBlbnVsdGltYXRlIHNlZ21lbnQgc2xvdC5cbiAgICBlbHNlIHtcbiAgICAgIHVuZGVyc2NvcmVJbkxhc3RMYXN0U2VnbWVudCA9IHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50XG4gICAgICB1bmRlcnNjb3JlSW5MYXN0U2VnbWVudCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkb21haW5JbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9ICovXG4gIGZ1bmN0aW9uIGRvbWFpbkFmdGVyKGNvZGUpIHtcbiAgICAvLyBOb3RlOiB0aGF04oCZcyBHSCBzYXlzIGEgZG90IGlzIG5lZWRlZCwgYnV0IGl04oCZcyBub3QgdHJ1ZTpcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vaXNzdWVzLzI3OT5cbiAgICBpZiAodW5kZXJzY29yZUluTGFzdExhc3RTZWdtZW50IHx8IHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50IHx8ICFzZWVuKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXRoLlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSBodHRwczovL2V4YW1wbGUub3JnL3N0dWZmIGJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVBhdGgoZWZmZWN0cywgb2spIHtcbiAgbGV0IHNpemVPcGVuID0gMFxuICBsZXQgc2l6ZUNsb3NlID0gMFxuXG4gIHJldHVybiBwYXRoSW5zaWRlXG5cbiAgLyoqXG4gICAqIEluIHBhdGguXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBeXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aEluc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmxlZnRQYXJlbnRoZXNpcykge1xuICAgICAgc2l6ZU9wZW4rK1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gcGF0aEluc2lkZVxuICAgIH1cblxuICAgIC8vIFRvIGRvOiBgbWFya2Rvd24tcnNgIGFsc28gbmVlZHMgdGhpcy5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcGFyZW4sIGFuZCB0aGVyZSBhcmUgbGVzcyBjbG9zaW5ncyB0aGFuIG9wZW5pbmdzLFxuICAgIC8vIHdlIGRvbuKAmXQgY2hlY2sgZm9yIGEgdHJhaWwuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnJpZ2h0UGFyZW50aGVzaXMgJiYgc2l6ZUNsb3NlIDwgc2l6ZU9wZW4pIHtcbiAgICAgIHJldHVybiBwYXRoQXRQdW5jdHVhdGlvbihjb2RlKVxuICAgIH1cblxuICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyB0cmFpbGluZyBwdW5jdHVhdGlvbiBtYXJrZXIgaXMgb3B0aW9uYWxseVxuICAgIC8vIGZvbGxvd2VkIGJ5IG1vcmUgdHJhaWxpbmcgbWFya2VycywgYW5kIHRoZW4gZm9sbG93ZWRcbiAgICAvLyBieSBhbiBlbmQuXG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZXhjbGFtYXRpb25NYXJrIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5xdW90YXRpb25NYXJrIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5hbXBlcnNhbmQgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmFwb3N0cm9waGUgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnJpZ2h0UGFyZW50aGVzaXMgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmFzdGVyaXNrIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5jb21tYSB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuZG90IHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5jb2xvbiB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuc2VtaWNvbG9uIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5sZXNzVGhhbiB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucXVlc3Rpb25NYXJrIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnVuZGVyc2NvcmUgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnRpbGRlXG4gICAgKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cy5jaGVjayh0cmFpbCwgb2ssIHBhdGhBdFB1bmN0dWF0aW9uKShjb2RlKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IGNvZGVzLmVvZiB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKSB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBwYXRoSW5zaWRlXG4gIH1cblxuICAvKipcbiAgICogSW4gcGF0aCwgYXQgcG90ZW50aWFsIHRyYWlsaW5nIHB1bmN0dWF0aW9uLCB0aGF0IHdhcyBub3QgdHJhaWxpbmcuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcImJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhdGhBdFB1bmN0dWF0aW9uKGNvZGUpIHtcbiAgICAvLyBDb3VudCBjbG9zaW5nIHBhcmVucy5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMucmlnaHRQYXJlbnRoZXNpcykge1xuICAgICAgc2l6ZUNsb3NlKytcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gcGF0aEluc2lkZVxuICB9XG59XG5cbi8qKlxuICogVHJhaWwuXG4gKlxuICogVGhpcyBjYWxscyBgb2tgIGlmIHRoaXMgKmlzKiB0aGUgdHJhaWwsIGZvbGxvd2VkIGJ5IGFuIGVuZCwgd2hpY2ggbWVhbnNcbiAqIHRoZSBlbnRpcmUgdHJhaWwgaXMgbm90IHBhcnQgb2YgdGhlIGxpbmsuXG4gKiBJdCBjYWxscyBgbm9rYCBpZiB0aGlzICppcyogcGFydCBvZiB0aGUgbGluay5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb21cIikuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIF5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVHJhaWwoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gdHJhaWxcblxuICAvKipcbiAgICogSW4gdHJhaWwgb2YgZG9tYWluIG9yIHBhdGguXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tXCIpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsKGNvZGUpIHtcbiAgICAvLyBSZWd1bGFyIHRyYWlsaW5nIHB1bmN0dWF0aW9uLlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IGNvZGVzLmV4Y2xhbWF0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucXVvdGF0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuYXBvc3Ryb3BoZSB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucmlnaHRQYXJlbnRoZXNpcyB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuYXN0ZXJpc2sgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmNvbW1hIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5kb3QgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmNvbG9uIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5zZW1pY29sb24gfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnF1ZXN0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMudW5kZXJzY29yZSB8fFxuICAgICAgY29kZSA9PT0gY29kZXMudGlsZGVcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsXG4gICAgfVxuXG4gICAgLy8gYCZgIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGFscGhhYmV0aWNhbHMgYW5kIHRoZW4gYSBgO2AsIGlzXG4gICAgLy8gYXMgYSB3aG9sZSBjb25zaWRlcmVkIGFzIHRyYWlsaW5nIHB1bmN0dWF0aW9uLlxuICAgIC8vIEluIGFsbCBvdGhlciBjYXNlcywgaXQgaXMgY29uc2lkZXJlZCBhcyBjb250aW51YXRpb24gb2YgdGhlIFVSTC5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuYW1wZXJzYW5kKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0cmFpbENoYXJSZWZTdGFydFxuICAgIH1cblxuICAgIC8vIE5lZWRlZCBiZWNhdXNlIHdlIGFsbG93IGxpdGVyYWxzIGFmdGVyIGBbYCwgYXMgd2UgZml4OlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9pc3N1ZXMvMjc4Pi5cbiAgICAvLyBDaGVjayB0aGF0IGl0IGlzIG5vdCBmb2xsb3dlZCBieSBgKGAgb3IgYFtgLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsQnJhY2tldEFmdGVyXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgLy8gYDxgIGlzIGFuIGVuZC5cbiAgICAgIGNvZGUgPT09IGNvZGVzLmxlc3NUaGFuIHx8XG4gICAgICAvLyBTbyBpcyB3aGl0ZXNwYWNlLlxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpIHx8XG4gICAgICB1bmljb2RlV2hpdGVzcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRyYWlsLCBhZnRlciBgXWAuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogdGhpcyBkZXZpYXRlcyBmcm9tIGBjbWFyay1nZm1gIHRvIGZpeCBhIGJ1Zy5cbiAgICogPiBTZWUgZW5kIG9mIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9pc3N1ZXMvMjc4PiBmb3IgbW9yZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb21dKFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB0cmFpbEJyYWNrZXRBZnRlcihjb2RlKSB7XG4gICAgLy8gV2hpdGVzcGFjZSBvciBzb21ldGhpbmcgdGhhdCBjb3VsZCBzdGFydCBhIHJlc291cmNlIG9yIHJlZmVyZW5jZSBpcyB0aGUgZW5kLlxuICAgIC8vIFN3aXRjaCBiYWNrIHRvIHRyYWlsIG90aGVyd2lzZS5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmxlZnRQYXJlbnRoZXNpcyB8fFxuICAgICAgY29kZSA9PT0gY29kZXMubGVmdFNxdWFyZUJyYWNrZXQgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhaWwoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBjaGFyYWN0ZXItcmVmZXJlbmNlIGxpa2UgdHJhaWwsIGFmdGVyIGAmYC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20mYW1wOykuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsQ2hhclJlZlN0YXJ0KGNvZGUpIHtcbiAgICAvLyBXaGVuIG5vbi1hbHBoYSwgaXTigJlzIG5vdCBhIHRyYWlsLlxuICAgIHJldHVybiBhc2NpaUFscGhhKGNvZGUpID8gdHJhaWxDaGFyUmVmSW5zaWRlKGNvZGUpIDogbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gY2hhcmFjdGVyLXJlZmVyZW5jZSBsaWtlIHRyYWlsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbSZhbXA7KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gdHJhaWxDaGFyUmVmSW5zaWRlKGNvZGUpIHtcbiAgICAvLyBTd2l0Y2ggYmFjayB0byB0cmFpbCBpZiB0aGlzIGlzIHdlbGwtZm9ybWVkLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5zZW1pY29sb24pIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsQ2hhclJlZkluc2lkZVxuICAgIH1cblxuICAgIC8vIEl04oCZcyBub3QgYSB0cmFpbC5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBEb3QgaW4gZW1haWwgZG9tYWluIHRyYWlsLlxuICpcbiAqIFRoaXMgY2FsbHMgYG9rYCBpZiB0aGlzICppcyogdGhlIHRyYWlsLCBmb2xsb3dlZCBieSBhbiBlbmQsIHdoaWNoIG1lYW5zXG4gKiB0aGUgdHJhaWwgaXMgbm90IHBhcnQgb2YgdGhlIGxpbmsuXG4gKiBJdCBjYWxscyBgbm9rYCBpZiB0aGlzICppcyogcGFydCBvZiB0aGUgbGluay5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGNvbnRhY3RAZXhhbXBsZS5vcmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZUVtYWlsRG9tYWluRG90VHJhaWwoZWZmZWN0cywgb2ssIG5vaykge1xuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogRG90LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgY29udGFjdEBleGFtcGxlLm9yZy5cbiAgICogICAgICAgICAgICAgICAgICAgIF4gICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgLy8gTXVzdCBiZSBkb3QuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGFmdGVyXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZG90LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgY29udGFjdEBleGFtcGxlLm9yZy5cbiAgICogICAgICAgICAgICAgICAgICAgICBeICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8vIE5vdCBhIHRyYWlsIGlmIGFscGhhbnVtZXJpYy5cbiAgICByZXR1cm4gYXNjaWlBbHBoYW51bWVyaWMoY29kZSkgPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogU2VlOlxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDE1Nj4uXG4gKlxuICogQHR5cGUge1ByZXZpb3VzfVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1d3dyhjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgY29kZSA9PT0gY29kZXMubGVmdFBhcmVudGhlc2lzIHx8XG4gICAgY29kZSA9PT0gY29kZXMuYXN0ZXJpc2sgfHxcbiAgICBjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlIHx8XG4gICAgY29kZSA9PT0gY29kZXMubGVmdFNxdWFyZUJyYWNrZXQgfHxcbiAgICBjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQgfHxcbiAgICBjb2RlID09PSBjb2Rlcy50aWxkZSB8fFxuICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSlcbiAgKVxufVxuXG4vKipcbiAqIFNlZTpcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9ibG9iL2VmMWNmY2IvZXh0ZW5zaW9ucy9hdXRvbGluay5jI0wyMTQ+LlxuICpcbiAqIEB0eXBlIHtQcmV2aW91c31cbiAqL1xuZnVuY3Rpb24gcHJldmlvdXNQcm90b2NvbChjb2RlKSB7XG4gIHJldHVybiAhYXNjaWlBbHBoYShjb2RlKVxufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7UHJldmlvdXN9XG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzRW1haWwoY29kZSkge1xuICAvLyBEbyBub3QgYWxsb3cgYSBzbGFzaCDigJxpbnNpZGXigJ0gYXRleHQuXG4gIC8vIFRoZSByZWZlcmVuY2UgY29kZSBpcyBhIGJpdCB3ZWlyZCwgYnV0IHRoYXTigJlzIHdoYXQgaXQgcmVzdWx0cyBpbi5cbiAgLy8gU291cmNlOiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMzA3Pi5cbiAgLy8gT3RoZXIgdGhhbiBzbGFzaCwgZXZlcnkgcHJlY2VkaW5nIGNoYXJhY3RlciBpcyBhbGxvd2VkLlxuICByZXR1cm4gIShjb2RlID09PSBjb2Rlcy5zbGFzaCB8fCBnZm1BdGV4dChjb2RlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBnZm1BdGV4dChjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgY29kZSA9PT0gY29kZXMucGx1c1NpZ24gfHxcbiAgICBjb2RlID09PSBjb2Rlcy5kYXNoIHx8XG4gICAgY29kZSA9PT0gY29kZXMuZG90IHx8XG4gICAgY29kZSA9PT0gY29kZXMudW5kZXJzY29yZSB8fFxuICAgIGFzY2lpQWxwaGFudW1lcmljKGNvZGUpXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcHJldmlvdXNVbmJhbGFuY2VkKGV2ZW50cykge1xuICBsZXQgaW5kZXggPSBldmVudHMubGVuZ3RoXG4gIGxldCByZXN1bHQgPSBmYWxzZVxuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBldmVudHNbaW5kZXhdWzFdXG5cbiAgICBpZiAoXG4gICAgICAodG9rZW4udHlwZSA9PT0gJ2xhYmVsTGluaycgfHwgdG9rZW4udHlwZSA9PT0gJ2xhYmVsSW1hZ2UnKSAmJlxuICAgICAgIXRva2VuLl9iYWxhbmNlZFxuICAgICkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZeKAmXZlIHNlZW4gdGhpcyB0b2tlbiwgYW5kIGl0IHdhcyBtYXJrZWQgYXMgbm90IGhhdmluZyBhbnkgdW5iYWxhbmNlZFxuICAgIC8vIGJyYWNrZXQgYmVmb3JlIGl0LCB3ZSBjYW4gZXhpdC5cbiAgICBpZiAodG9rZW4uX2dmbUF1dG9saW5rTGl0ZXJhbFdhbGtlZEludG8pIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudHMubGVuZ3RoID4gMCAmJiAhcmVzdWx0KSB7XG4gICAgLy8gTWFyayB0aGUgbGFzdCB0b2tlbiBhcyDigJx3YWxrZWQgaW50b+KAnSB3L28gZmluZGluZ1xuICAgIC8vIGFueXRoaW5nLlxuICAgIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uX2dmbUF1dG9saW5rTGl0ZXJhbFdhbGtlZEludG8gPSB0cnVlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiYXNjaWlBbHBoYSIsImFzY2lpQWxwaGFudW1lcmljIiwiYXNjaWlDb250cm9sIiwibWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSIsInVuaWNvZGVQdW5jdHVhdGlvbiIsInVuaWNvZGVXaGl0ZXNwYWNlIiwiY29kZXMiLCJ3d3dQcmVmaXgiLCJ0b2tlbml6ZSIsInRva2VuaXplV3d3UHJlZml4IiwicGFydGlhbCIsImRvbWFpbiIsInRva2VuaXplRG9tYWluIiwicGF0aCIsInRva2VuaXplUGF0aCIsInRyYWlsIiwidG9rZW5pemVUcmFpbCIsImVtYWlsRG9tYWluRG90VHJhaWwiLCJ0b2tlbml6ZUVtYWlsRG9tYWluRG90VHJhaWwiLCJ3d3dBdXRvbGluayIsInRva2VuaXplV3d3QXV0b2xpbmsiLCJwcmV2aW91cyIsInByZXZpb3VzV3d3IiwicHJvdG9jb2xBdXRvbGluayIsInRva2VuaXplUHJvdG9jb2xBdXRvbGluayIsInByZXZpb3VzUHJvdG9jb2wiLCJlbWFpbEF1dG9saW5rIiwidG9rZW5pemVFbWFpbEF1dG9saW5rIiwicHJldmlvdXNFbWFpbCIsInRleHQiLCJnZm1BdXRvbGlua0xpdGVyYWwiLCJjb2RlIiwiZGlnaXQwIiwibGVmdEN1cmx5QnJhY2UiLCJjb2xvbiIsInVwcGVyY2FzZUEiLCJsZWZ0U3F1YXJlQnJhY2tldCIsImxvd2VyY2FzZUEiLCJwbHVzU2lnbiIsImRhc2giLCJkb3QiLCJ1bmRlcnNjb3JlIiwidXBwZXJjYXNlSCIsImxvd2VyY2FzZUgiLCJ1cHBlcmNhc2VXIiwibG93ZXJjYXNlVyIsImVmZmVjdHMiLCJvayIsIm5vayIsInNlbGYiLCJkYXRhIiwic3RhcnQiLCJnZm1BdGV4dCIsImNhbGwiLCJwcmV2aW91c1VuYmFsYW5jZWQiLCJldmVudHMiLCJlbnRlciIsImF0ZXh0IiwiY29uc3VtZSIsImF0U2lnbiIsImVtYWlsRG9tYWluIiwiY2hlY2siLCJlbWFpbERvbWFpbkFmdGVyIiwiZW1haWxEb21haW5Eb3QiLCJleGl0Iiwid3d3U3RhcnQiLCJhdHRlbXB0Iiwid3d3QWZ0ZXIiLCJidWZmZXIiLCJzZWVuIiwicHJvdG9jb2xTdGFydCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJwcm90b2NvbFByZWZpeEluc2lkZSIsImxlbmd0aCIsInByb3RvY29sIiwidG9Mb3dlckNhc2UiLCJwcm90b2NvbFNsYXNoZXNJbnNpZGUiLCJzbGFzaCIsImFmdGVyUHJvdG9jb2wiLCJlb2YiLCJwcm90b2NvbEFmdGVyIiwic2l6ZSIsInd3d1ByZWZpeEluc2lkZSIsInd3d1ByZWZpeEFmdGVyIiwidW5kZXJzY29yZUluTGFzdFNlZ21lbnQiLCJ1bmRlcnNjb3JlSW5MYXN0TGFzdFNlZ21lbnQiLCJkb21haW5JbnNpZGUiLCJkb21haW5BZnRlciIsImRvbWFpbkF0UHVuY3R1YXRpb24iLCJ1bmRlZmluZWQiLCJzaXplT3BlbiIsInNpemVDbG9zZSIsInBhdGhJbnNpZGUiLCJsZWZ0UGFyZW50aGVzaXMiLCJyaWdodFBhcmVudGhlc2lzIiwicGF0aEF0UHVuY3R1YXRpb24iLCJleGNsYW1hdGlvbk1hcmsiLCJxdW90YXRpb25NYXJrIiwiYW1wZXJzYW5kIiwiYXBvc3Ryb3BoZSIsImFzdGVyaXNrIiwiY29tbWEiLCJzZW1pY29sb24iLCJsZXNzVGhhbiIsInF1ZXN0aW9uTWFyayIsInJpZ2h0U3F1YXJlQnJhY2tldCIsInRpbGRlIiwidHJhaWxDaGFyUmVmU3RhcnQiLCJ0cmFpbEJyYWNrZXRBZnRlciIsInRyYWlsQ2hhclJlZkluc2lkZSIsImFmdGVyIiwiaW5kZXgiLCJyZXN1bHQiLCJ0b2tlbiIsInR5cGUiLCJfYmFsYW5jZWQiLCJfZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js\n");

/***/ })

};
;